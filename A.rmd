---
title: "Problem A"
author: "Sivert Selnes"
date: "March 28, 2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("probAhelp.R")
source("probAdata.R")
```


### 1)
The residual bootstrap method relies on independent and identically distributed residuals to resample. Hence the carrying assumption is that our data origins from a process that is captured by the model, in this case a autoregressive process of second order. The computed rediduals will therefore by i.i.d. and appropriate to resample. The residual bootstrap method goes as following:

* Estimate the AR(2) coefficients $\alpha_1$ and $\alpha_2$.

* Define the innovations $\hat{e}_t = X_t - \hat{\alpha_1}X_{t-1} - \hat{\alpha_2}X_{t-2}$.

* Ensure that the residuals have zero mean, $\hat{\epsilon}_t = \hat{e}_t - \bar{e}$.

* Resample $n+1$ values from $\{\hat{\epsilon}_2, ..., \hat{\epsilon}_n \}$

* Reconstruct a pseudo data series, $X_0^* = \epsilon_0^*, \quad X_t^* = \hat{\alpha_1}X_{t-1} + \hat{\alpha_2}X_{t-2} +\epsilon_t^*$


```{r}
ts = data3A$x # fetch time series
n = length(ts)

beta_estimate = ARp.beta.est(ts,2) # get AR(2) parameters estimates
res_LS = ARp.resid(ts, beta_estimate$LS) # LS residuals for bootstrapping
res_LA = ARp.resid(ts, beta_estimate$LA) # LA residuals for bootstrapping

mean(res_LS) # Ensure zero mean
mean(res_LA) # 

B = 15000
boot_LS = matrix(NA,B,2)
boot_LA = matrix(NA,B,2)

# Reconstruct the pseudo data series using LS and estimate model parameters 
for (i in 1:B) {
  e_sample = sample(res_LS, length(res_LS), replace=T) # resample the residuals
  init = sample(1:(n-1), 1, replace = T) # random intializing index for filtering
  x0 = ts[init:(init+1)]
  x_pseudo = ARp.filter(x0, beta_estimate$LS, e_sample)
  beta_boot = ARp.beta.est(x_pseudo,2)$LS
  boot_LS[i,] = beta_boot
}


# Repeat procedure: Bootstrap the LA method 
for (i in 1:B) {
  e_sample = sample(res_LA, length(res_LA), replace=T) # resample the residuals
  init = sample(1:(n-1), 1, replace = T) # random intializing index for filtering
  x0 = ts[init:(init+1)]
  x_pseudo = ARp.filter(x0, beta_estimate$LA, e_sample)
  beta_boot = ARp.beta.est(x_pseudo,2)$LA
  boot_LA[i,] = beta_boot
}
hist(boot_LS[,1], 30)
hist(boot_LA[,1], 30)
hist(boot_LS[,2], 30)
hist(boot_LA[,2], 30)


# Bias and variance estimate

bias_LS1 = mean(boot_LS[,1])-beta_estimate$LS[1]
bias_LS2 = mean(boot_LS[,2])-beta_estimate$LS[2]

bias_LA1 = mean(boot_LA[,1])-beta_estimate$LA[1]
bias_LA2 = mean(boot_LA[,2])-beta_estimate$LA[2]

var_LS1 = sum((boot_LS[,1]-beta_estimate$LS[1])^2)/B
var_LS2 = sum((boot_LS[,2]-beta_estimate$LS[2])^2)/B

var_LA1 = sum((boot_LA[,1]-beta_estimate$LA[1])^2)/B
var_LA2 = sum((boot_LA[,2]-beta_estimate$LA[2])^2)/B

```
















